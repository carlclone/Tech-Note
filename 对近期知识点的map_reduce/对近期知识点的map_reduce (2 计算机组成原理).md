## 对近期知识点的map_reduce (2 计算机组成原理)



### 浮点数表示 IEEE754标准



浮点数的产生过程 , 用尽量少的占用位置表示尽量大的数字 , 一张小纸无法写下有82位的整数 , 但科学计数法可以 .



#### 部分十进制浮点数无法精确表示的原因

将0.1十进制数转换为二进制数的过程 , 将小数点右移 , 也就是X2 , 取整数部分,直到小数部分为0

0.1X2=0.2      0.0

0.2X2=0.4      0.00

0.4X2=0.8	  0.000

0.8X2=1.6	  0.0001

0.6X2=1.2	  0.00011

0.2X2=0.4	  0.000110

开始无限循环.......

而浮点数的有效位是有限的 , 因此出现了误差



#### 浮点数的加法 

先对齐指数位(小的向大的对齐) , 然后有效位相加 , 因此较小的数在对齐的时候也会损失精度 , 指数位相差越大 , 相加的误差就越大 , 

例子:



解决浮点数加法问题的方案 : Kahan Summation 算法





#### 定点数(Decimal)

浮点数适合不需要非常精确结果的情况

如果想要精确表示十进制小数 , 小数位确定 , 可以使用定点数(Decimal) 

定点数的表示法是: 一部分比特用来表示整数部分 , 一部分比特用来表示小数 , 缺点是能表示的数字范围很小

0.1的定点数表示 , 假设计算机只能处理8比特,不考虑负数

前面4比特可以表示整数范围0-9 , 后面4比特表示小数范围0-9 , 可表示0-9.9的数

0000 0001

应用场景 , 最常用的是在超市、银行这样需要用小数记录金额的情况里。在超市里面，我们的小数最多也就到分



#### 历史上惨重的浮点数事件 , 警示!!!!

1991年海湾战争 , 导弹计算失误致使美军28人死亡260人受伤 , 0.000000095的时间误差, 在距离上被放大到573米 , 防御系统没有启动 (生命的代价)

1996年欧洲宇航局, 10多亿美元的航天器在39秒后烟消云散 , 源于错误地把浮点数当做整型使用 , 看似极其小的问题被无限放大

1980年温哥华股票交易所, 使用floor去掉了小数位 , 在每天数百万次的交易中积累成天文数字





#### 延伸

业务上的处理方法 : 银行家算法

实现一遍IEEE754 , 实现一遍事件循环模型

OAUTH模型的演化过程



#### 问题

1. 64位的浮点数加法在相差多大后 , 小的那个数完全丢失?

2. PHP中的浮点数底层是如何处理的 , 和IEEE754的浮点数表现不一样



#### 参考资料

1.计算机组成原理课15 ,16

2.公众号<是不是很酷> - 浮点数文章

https://mp.weixin.qq.com/s/0KDPWQXhBIsDDQwo3FYlag

3.网页资料 

https://www.jianshu.com/p/7c636d8f18d5

4.IEEE754 

https://ieeexplore.ieee.org/document/4610935

https://zh.wikipedia.org/zh-hans/IEEE_754

5.实现参考 

https://blog.csdn.net/crjmail/article/details/79723051



### 为什么while(true){}会把cpu占用率打满,while(true){sleep(1)}不会

以下内容是当前的理解,不一定正确 

 cpu占用率的定义 , 某个时间的cpu时间片实际有线程在运行的时间



sleep(1)会阻塞当前线程(放入等待队列) , 而{} 会分尽量多的时间片给当前线程 



参考https://www.v2ex.com/t/622020#reply34

https://www.v2ex.com/t/352157

https://blog.csdn.net/zhuyijian135757/article/details/42269329

https://blog.csdn.net/liangrui1988/article/details/79230480

https://www.jianshu.com/p/669015fc537c

https://bbs.csdn.net/topics/390478522



cpu利用率

http://www.easemob.com/news/1242



```
		       
ipwx   
这种典型就是操作系统原理没学过才会发出的疑问。科班还是有科班的底蕴的。
		        
ipwx   
这么说吧，线程占用 cpu 必须是在运行，而线程被操作系统调度才会被运行。因为 io 或者其他原因阻塞，线程会进入操作系统的等待队列，不会被运行。线程即使不进入阻塞，也不一定一直运行，操作系统随时可以打断线程，让它暂停，让渡资源给别的线程运行一段时间，再切换回来。当然资源充足情况下操作系统一般不会主动打断线程运行。
```



关键词 java 无限循环 阻塞 cpu占用率实际是什么