## 对近期知识点的map_reduce (1 网络编程设计/策略)


目标: 能用自己的话精炼正确地总结出每一节的知识点 , 就算完成目标了


### 浏览器课 15丨消息队列和事件循环：页面是怎么“活”起来的？



##### 事件循环模型的演化过程?

>  背景 : 有多个任务要执行



1.最基本的顺序执行

2.为了解决1中不能在执行途中插入新的任务 , 新增了"循环"和"事件"

3.为了解决2中不能接收来自其他线程的任务,新增了"消息队列" , 并且在从队列中获取任务的时候需要加锁 , 是block queue

4 更进一步想要接收来自其他进程的任务 , 需要IPC通信 , 然后有一个专门的线程负责接收并插入队列 , 这个线程就是IO线程  (chrome浏览器中 , 渲染主线程负责事件执行 , IO线程负责事件分发)



### 网络编程课 20丨大名⿍⿍的select：看我如何同时感知多个I-O事件



##### 什么是IO多路复用?

一个网络程序里通常会有多种IO , 比如 标准输入输出 , 网络套接字IO , 在单进程的情况下 , 一般只能阻塞在一种IO上等待 , 而IO多路复用就类似上面的事件循环 , 将多种IO看成不同的事件 , 解决了阻塞在一种IO上的问题

在这里 , 内核则相当于上文中派发任务的"IO进程"  , 应用程序则相当于"渲染进程"

但有一个区别是,linux的多路复用实现并没有用到队列 ,  非linux的kqueue实现则使用了队列



##### select的使用方法?
设置一个描述符集合 , 一个读事件集合 , 写事件集合 , 异常事件集合 
描述符基数是当前最大描述符 +1；
每次 select 调用完成之后，记得要重置待测试集合



##### SIGPIPE信号是什么?

待查资料



##### select可以对unix管道(pipe)进行检测么? 检测的就绪条件是什么?

待查资料



##### 根据我们前面的描述，一个描述符集合哪些描述符被设置为 1，需要进行检测是完全可以知道的，你认为 select 函数里一定需要传入描述字基数这个值么？请你分析一下这样设计的目的又是什么呢？

因为内核扫描集合是从大到小扫描的 , 比如集合{ 0 , 1 ,4 } ,  4表示为 fd[5-1] , 如果没有给基数, 内核还需要多扫描一遍获得这个数 , 但又引出一个问题 , 为什么要从大到小扫描? 突然想起一个"局部性原理" , 越接近当前时间生成的描述符越容易被访问到(越容易有事件发生 ) , 类似LRU缓存 , 是这样吗?



### 网络编程课 21丨poll：另一种I-O多路复用

> 产生背景: select默认最大值为1024



##### 使用方法?

传入pollfd结构体组成的数组 , 数组大小可以突破1024 , pollfd的结构:

```
struct pollfd {
    int    fd;       /* file descriptor */
    short  events;   /* events to look for */
    short  revents;  /* events returned */
 };
```



##### 第一道，在我们的程序里 event_set 数组的大小固定为 INIT_SIZE，这在实际的生产环境肯定是需要改进的。你知道如何改进吗？

使用数据结构课中的动态数组的扩容缩容方案



##### 第二道，如果我们进行了改进，那么接下来把连接描述字 connect_fd 也加入到 event_set 里，如何配合进行改造呢？



### 网络编程课 22丨非阻塞I-O：提升性能的加速器



##### 高性能网络编程的演进过程?

1.阻塞IO , 等待内核完成

2.非阻塞IO, 立即返回 ,  使用轮询检查完成情况

3.非阻塞IO+多路复用 , 减少轮询造成的CPU时间浪费

需要特别注意非阻塞的write操作 , 每次都可能只write了一部分到发送缓冲区 , 所以要用偏移量把剩下的在后面继续发出去 ( 因此各自框架抽象出了buffer , 隐藏对socket字节流的直接操作 )

```
ssize_t writen(int fd, const void * data, size_t n)
{
    size_t      nleft;
    ssize_t     nwritten;
    const char  *ptr;
 
    ptr = data;
    nleft = n;
    // 如果还有数据没被拷贝完成，就一直循环
    while (nleft > 0) {
        if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
           /* 这里 EINTR 是非阻塞 non-blocking 情况下，通知我们再次调用 write() */
            if (nwritten < 0 && errno == EINTR)
                nwritten = 0;      
            else
                return -1;         /* 出错退出 */
        }
 
        /* 指针增大，剩下字节数变小 */
        nleft -= nwritten;
        ptr   += nwritten;
    }
    return n;
}
```

作者还描述了read和write在不同模式下各自可能的异常 , 之后实操可以用到



##### 这一节的代码比较多, 思考题也还没看?





### 网络编程课 23 | Linux利器：epoll的前世今生

![image-20191120140931373](/Users/mojave/MY_CAREER_LIFE/Tech-Note/imgs/浏览器工作原理与实践总结/image-20191120140931373.png)



##### 使用方法?

epoll_create() 创建epoll实例
epoll_ctl 增加删除 事件
epoll_wait() 挂起进程 , 等待内核IO事件分发



##### 边缘触发 VS 条件触发 ?

后面有一节, 好像是epoll源码解析的, 讲到了他们的底层实现
目前的理解: 边缘触发只触发一次(只有第一次满足条件的时候才触发) , 条件触发会触发多次 , 直到进行了read操作读取

ET比LT效率要高 , 但异常处理也更为复杂

这部分只涉及到高效性的问题 , 无需重点关注



##### events的二进制mask 设计 ?
EPOLLIN | EPOLLET
二进制遍历int mask的方法: 



##### 实践题两道 , 修改20节select的代码 , 看看是ET还是LT ,  同理修改21节poll的代码



##### epoll惊群问题?





### 网络编程课 24 | C10K问题：高并发模型设计



##### C10K = ?

C10K = Client 10000 or Connection 10000 =  10000个并发连接 ?



##### 演化过程?

> 主要线索: 如何感知和调度IO事件 (阻塞/非阻塞 , 多路复用),处理上万个套接字的IO  , 如何分配进程,线程资源给上万个连接?



1.阻塞IO+进程



2.阻塞IO+线程



3.非阻塞IO轮询+线程



4.非阻塞IO+多路复用+线程   (避免轮询浪费CPU时间,交出控制权)



5.非阻塞IO+多路复用+多线程 , 所谓的主从reactor模式 , epoll事件分发器可以叫做reactor , 也叫事件驱动或eventloop , 也就是浏览器渲染的运行方式 , 主渲染 , 从进行事件分发



6.异步非阻塞IO+多线程 , AIO相关的在30节有说 , 没有深入了解



##### Netty是 用哪种模型?

reactor模型 , 底层是Java的NIO



##### C10M问题? 单机处理千万级并发 , 能实现吗 , 瓶颈在哪?





### 04丨TCP三次握手：怎么使用套接字格式建立连接?



1 确认SN



2.这个问题的本质是, 双方基于"信道不可靠"的前提下的通信, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的



3.建立两个单向连接的过程

客户端结束阻塞在connect  , ESTABLISHED 客户端到服务端的单向连接

服务端结束阻塞在accept , ESTABLISHED 服务端到客户端的单向连接





### 网络编程课11丨优雅地关闭还是粗暴地关闭



close 直接关闭单向读写

shutdown只关闭单向写 , 等到对方发送FIN才关闭单向读

close后,继续发送数据的话,会收到RST报文,  继续写入会触发SIGPIPE信号 , 不处理会发送错误





### 网络编程课  10丨TIME-WAIT：隐藏在细节下的魔鬼



1 保证被动关闭方收到ACK  ( 否则被动方重发FIN的时候会收到RST报文, 关闭错误)

2 避免旧连接的迷路报文影响新的"化身"连接 ( 2MSL的时间保证报文消失)



过多的解决方案:

复用TIME_WAIT端口

减少TIME_WAIT时间



不适合的解决方案 和造成的后果:

跳过TIME_WAIT

暴力重置连接状态

SO_LINGER强制关闭





