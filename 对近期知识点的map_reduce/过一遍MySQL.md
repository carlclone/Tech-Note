

### 一条查询语句的执行过程







通过tcp连接

权限修改后只影响之后新建的连接



show processlist命令



连接空闲时间 wait_timeout参数,默认8小时



连接过多爆内存情况  / 解决方案

定期断开长连接

Mysql_reset_connection



避免使用mysql自带查询缓存 , 缓存失效频繁 ,命中率低

query_cache_type = DEMAND , 不使用查询缓存

8.0已经删掉查询缓存功能 , 不用管了





词法/语法分析 , 生成AST

词法 语法分析各自的作用?

词法负责分词 , 语法负责检查错误?



优化器

比如 优化join连接顺序



执行器

没索引的情况 , 扫描全部判断是否符合, 放入结果集



## 一条更新语句的执行过程



思考这些设计的时候 , 脑子里要由的前置条件是 设计者不信任运行环境 (随时会崩溃)

redolog 引擎层,innodb才有, 顺序写文件 , crash-safe , 

不太理解为什么可以crash-safe , 原来是相对myisam来说的(myisam不支持事务啊) , 同时还要知道两阶段提交

binlog server层

两阶段提交, 保证多人场景的一致 , 比如分布式场景下各个服务器 , 这里是保证redo和binlog一致 , 都提交了才能提交



redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。

sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。







### 隔离

背景:多个事务同时执行,互相影响

隔离级别中的可重复读是通过多版本快照实现的





### 索引

磁盘访问一个数据块的时间是10ms

为了减少对磁盘数据块的访问次数 , 将二叉树扩展成N叉



索引的数据结构演化 / 提升查询效率的演化

有序数组

哈希表

二叉树

N叉树



> 以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。



Clustered index存了整行数据

secondary index只存了clustered index主键的值 , 查的时候要多去clustered再查一遍



增删改时候 树节点的分裂 , 合并

用自增则不会发生分裂合并 , 主键长度也是越小越好 , 能用int就别用varchar



如何避免长事务对业务的影响?

重建索引的合理做法 ,哪个更好?

alter table T drop primary key; 

alter table T add primary key(id);



### 索引2



如何判断一条查询 扫描索引的次数?



覆盖索引 , 覆盖查询字段 , 不必回表额外查



最左前缀 ,  从左到右依次有序



多列索引的结构

![image-20191202171814497](/Users/mojave/MY_CAREER_LIFE/Tech-Note/对近期知识点的map_reduce/imgs/过一遍MySQL/image-20191202171814497.png)



select * from tuser where name like '张%' and age=10 and ismale=1; 也可以用到索引

找到张的第一个 , 然后遍历下去 





问题1:

a,b联合主键

select * from geek where c=N order by a limit 1; select * from geek where c=N order by b limit 1;

ca , cb索引都是必要的吗

ca没必要, 节省空间 , 最左前缀





### 锁



表锁 , 一般是不支持行锁的引擎才会用到 

lock tables  ... read/write

MDL 隐式表锁 ,  不支持行锁的引擎 / 修改表结构



### 行锁



如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**





### 死锁

解决方案 

设置超时 innodb_lock_wait_timeout , 默认50s

开启死锁检测 innodb_deadlock_detect , 主动回滚某一个事务 , 有额外cpu消耗(两层循环检查各个事务)



1.确保业务一定没死锁,  可以关掉死锁检测

2.控制并发数 , 降低死锁检测的成本

3.设计上的优化 , 一行改多行 , 减少锁冲突  (如账户总额,分到多行来记录 , 类似redis多个计数器,再汇总的设计 , 提高并发减少等待和冲突)



### 事务



注意! begin之后第一条语句才创建视图(快照)  , 除非显式创建视图(快照) ,  事务的起点是第一条语句 , 不是begin

MVCC的一致性读视图 , 用于读提交和可重复读



快照的结构

![image-20191203103931532](/Users/mojave/MY_CAREER_LIFE/Tech-Note/对近期知识点的map_reduce/imgs/过一遍MySQL/image-20191203103931532.png)



当前读的概念

update语句和select加锁的语句都是当前读,不会读快照





- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据；

而当前读，总是读取已经提交完成的最新版本。





### 普通索引 唯一索引

- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。



InnoDB的数据是按数据页为单位来读写的 每个数据页的大小默认是16KB。

这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响(唯一索引要检查唯一性约束)。所以，我建议你尽量选择普通索引。

**redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。**





### 选错索引的场景



频繁删除历史数据和新增数据



优化器判断准则

扫描行数 , 根据 区分度粗略估计 cardinality , analyze table t 重新抽样统计,校准

临时表

是否需要排序

使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的。也就是说，这个策略并没有问题。



解决方案

force index

**新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。**



### 字符串字段加索引

前缀索引 , 可以压缩索引 , 缺点是可能扫描的行数增多 ,  尽量选择	区分度高(可以通过统计得出)的字符串长度



业务上的考量 

1. 身份证后几位区分度高 , 倒序存储 , 查的时候倒过来再查库 , 缺点,不支持范围查询

2. hash身份证, 然后在hash字段建索引 , hash可能冲突, 查完要再判断一遍id_num

   

   

   

   到第14

   

   

   

   SQL mysql底层原理 , mysql运维 3个要点

   