
笔记：
底层的远程调用交给Stub ， Stub处理完后按照Service定义的参数返回

Stub代处理繁琐的远程调用

对比我之前写的RemoteCallService ， RPC多做了哪些通用化


依赖倒置 ： 依赖接口而不是具体实现 ， decouple实现类和依赖类
依赖注入： decouple 实现类，第三方实例化类，依赖类
实现方式：java的SPI + XML配置 ， Spring boot 和 Laravel里的容器+反射
案例：  生成Stub的具体实现 和调用生成Stub的依赖类

Stub的概念？
1.客户端调用的Service的代理类，负责获取服务地址，根据定义的参数和返回值 发送远程调用和获取结果
2.根据给定的Service定义，生成封装参数和返回结果，远程调用的代理类
3.这里只适配生成一种语言 ，如果要多种的话得统一服务的定义（IDL）
4.简化成Service只能有一个方法，方法只有一个string类型的参数和返回值

RPC的构成
RPC AccessPoint 客户端获取服务的Stub ，服务端获取服务的实例
NameService 注册，获取服务地址
Stub 看上面
Transport接口用于封装通信

Java的Future好像类似JS的Promise


网络和通信 ， 异步 是我目前最难搞的地方了



序列化，反序列化 ☑️
协议设计 ☑️
异步网络IO ，异步设计 X


使用代理模式，可以动态注入非侵入式业务逻辑 ， 非侵入式指的是不用修改上下游代码
案例：Stub和Service ，原方法 和包裹方法计算耗时

/*
比如说，我们要监控一个方法 A 的请求耗时，普通的方式就是在方法的开始和返回这两个地方各加一条记录时间的语句，这种方法就需要修改这个方法的代码，这是一种“侵入式”的方式。
我们还可以给这个方法所在的类创建一个代理类，在这个代理类的 A 方法中，先记录开始时间，然后调用委托类的 A 方法，再记录结束时间。把这个代理类加入到调用链中，就可以实现“非侵入式”记录耗时了。同样的方式，我们还可以用在权限验证、风险控制、调用链跟踪等等这些场景中。

/*


### 请求和响应的设计

```
RequestHeader {
    requestId 用于双工通信匹配 ， 发出请求后存放到inFlightRequests（在途中的请求） ， 收到响应后匹配查询
    version 版本变化的时候，向下兼容，或放弃兼容 ， 仅仅代表协议的版本号，和业务层程序的无关
    type 请求的类型，目前只有一种RPC请求    
}

ResponseHeader {
    code 状态码 0正确，其他代表各种错误
    error 文字描述
}
```

根据请求类型分发给对应处理器的设计
根据命令的请求类型分发给对应的处理器
根据请求的服务分发到服务的对应实例上



## 05 消息丢失问题

可能发生丢失的时间：


exactly once
at most once
at least once

## 06重复消费的解决策略

1.接口实现幂等性 （多次请求和一次请求一样）
实现的方案：
请求带上requestId，服务端验证是否已经处理


## 09 如何阅读开源代码

1.带着一个问题去读

## 10 为什么异步设计可以提升系统性能

## 11 为什么异步网络传输可以提高性能

## 12 序列化的几种实现
优点：
通用序列化(json) 可读 
专用序列化() 省空间 

## 13 协议设计要点

## 14 内存管理的问题

高并发时候GC是如何造成的卡顿


如何减少GC时间？
避免创建一次性对象
使用对象池
使用更大内存的服务器

